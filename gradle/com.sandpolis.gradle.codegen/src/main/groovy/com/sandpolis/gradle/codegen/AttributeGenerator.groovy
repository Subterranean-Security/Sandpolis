/******************************************************************************
 *                                                                            *
 *                    Copyright 2018 Subterranean Security                    *
 *                                                                            *
 *  Licensed under the Apache License, Version 2.0 (the "License");           *
 *  you may not use this file except in compliance with the License.          *
 *  You may obtain a copy of the License at                                   *
 *                                                                            *
 *      http://www.apache.org/licenses/LICENSE-2.0                            *
 *                                                                            *
 *  Unless required by applicable law or agreed to in writing, software       *
 *  distributed under the License is distributed on an "AS IS" BASIS,         *
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  *
 *  See the License for the specific language governing permissions and       *
 *  limitations under the License.                                            *
 *                                                                            *
 *****************************************************************************/
package com.sandpolis.gradle.codegen

import com.squareup.javapoet.ClassName
import com.squareup.javapoet.JavaFile
import com.squareup.javapoet.ParameterizedTypeName
import com.squareup.javapoet.FieldSpec
import com.squareup.javapoet.TypeSpec

import javax.lang.model.element.Modifier

import org.gradle.api.DefaultTask
import org.gradle.api.tasks.TaskAction

import org.yaml.snakeyaml.Yaml

/**
 * Generator for attribute definition files.
 *
 * @author cilki
 */
class AttributeGenerator extends DefaultTask {

	@TaskAction
	void action () {

		// The module's attribute domain
		def domain = getProject().getName().equals("com.sandpolis.core.profile") ? null : "\"${getProject().getName()}\""

		// Parse the attribute file
		new Yaml().load(getProject().file("attribute.yml").text).each {
			def (name, tag, description) = parseNameTag(it)

			def ak = TypeSpec.classBuilder("AK_" + name.toUpperCase())
				.addModifiers(Modifier.PUBLIC, Modifier.FINAL)

			processGroup(ak, it, "com.sandpolis.core.profile.store.DomainStore.get($domain)")

			// Write out
			JavaFile.builder((domain == null) ? "com.sandpolis.core.attribute.key" : getProject().getName(), ak.build())
				.addFileComment("This file is automatically generated. Do not edit!")
				.skipJavaLangImports(true).build().writeTo(getProject().file("gen/main/java"));

		}
	}

	/**
	 * Convert the given YAML group into a field along with its children.
	 */
	void processGroup (ak, group, parent) {
		def (name, tag, description) = parseNameTag(group)

		ak.addField(FieldSpec.builder(ClassName.bestGuess("com.sandpolis.core.attribute.AttributeGroupKey"),
				name, Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)
			.initializer("new AttributeGroupKey($parent, ${tag}, ${group.get('plurality', 0)})")
			.addJavadoc('$L.\n', description).build())

		group['children'].each {
			if (it['children'])
				processGroup(ak, it, name)
			else
				processAttribute(ak, it, name)
		}
	}

	/**
	 * Convert the given YAML attribute into a field.
	 */
	void processAttribute (ak, attribute, parent) {
		def (name, tag, description) = parseNameTag(attribute)

		def initializer = "AttributeKey.newBuilder($parent, $tag).setDotPath(\"${parent.toLowerCase()}.$name\")"
		if (attribute['static'])
			initializer += ".setStatic(${attribute['static']})"

		ak.addField(FieldSpec.builder(ParameterizedTypeName.get(ClassName.bestGuess("com.sandpolis.core.attribute.AttributeKey"),
				ClassName.bestGuess(attribute['type'])), name.toUpperCase(), Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL)
			.initializer(initializer + ".build()")
			.addJavadoc('$L.\n', description).build())
	}

	/**
	 * Parse the name, tag, and description out of a map.
	 */
	def parseNameTag (map) {
		def firstEntry = map.entrySet().iterator().next()
		def nametag = firstEntry.getKey().split("=")
		if (nametag.length != 2)
			throw new RuntimeException("Invalid line: " + firstEntry.getKey());

		return [nametag[0].trim(), nametag[1].trim(), firstEntry.getValue().trim()]
	}
}
