//============================================================================//
//                                                                            //
//                Copyright Â© 2015 - 2020 Subterranean Security               //
//                                                                            //
//  This source file is subject to the terms of the Mozilla Public License    //
//  version 2. You may not use this file except in compliance with the MPL    //
//  as published by the Mozilla Foundation at:                                //
//                                                                            //
//    https://mozilla.org/MPL/2.0                                             //
//                                                                            //
//=========================================================S A N D P O L I S==//
package com.sandpolis.gradle.codegen.profile_tree.impl;

import static javax.lang.model.element.Modifier.PRIVATE;
import static javax.lang.model.element.Modifier.PUBLIC;

import java.io.IOException;
import java.util.List;

import org.gradle.api.DefaultTask;
import org.gradle.api.tasks.TaskAction;

import com.squareup.javapoet.AnnotationSpec;
import com.squareup.javapoet.ArrayTypeName;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.FieldSpec;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterizedTypeName;
import com.squareup.javapoet.TypeName;
import com.squareup.javapoet.TypeSpec;

/**
 * Generator for attribute implementations.
 *
 * @author cilki
 */
public class AttributeImplementationGenerator extends DefaultTask {

	private static final List<String> entityTypes = List.of( //
			"java.lang.String", //
			"java.lang.Boolean", //
			"java.lang.Integer", //
			"java.lang.Long", //
			"java.lang.Double", //
			"java.util.Date" //
	);
	private static final List<String> arrayTypes = List.of( //
			"java.lang.Byte[]" //
	);

	private static final List<String> convertableTypes = List.of( //
			"com.sandpolis.core.foundation.Platform.OsType", //
			"com.sandpolis.core.instance.Metatypes.InstanceType", //
			"com.sandpolis.core.instance.Metatypes.InstanceFlavor", //
			"java.security.cert.X509Certificate" //
	);

	@TaskAction
	public void action() {

		entityTypes.stream().forEach(type -> {
			try {
				generateAttributeImpl(type);
				generateListAttributeImpl(type);
			} catch (IOException e) {
				throw new RuntimeException(e);
			}
		});

		arrayTypes.stream().forEach(type -> {
			try {
				generateAttributeImpl(type);
			} catch (IOException e) {
				throw new RuntimeException(e);
			}
		});

		convertableTypes.stream().forEach(type -> {
			try {
				generateConverter(type);
				generateAttributeImpl(type);
				generateListAttributeImpl(type);
			} catch (IOException e) {
				throw new RuntimeException(e);
			}
		});
	}

	public void generateAttributeImpl(String attributeType) throws IOException {
		var type = Utils.toType(attributeType);

		var attributeClass = TypeSpec
				.classBuilder(ClassName.bestGuess(attributeType).simpleName().replace("[]", "Array") + "Attribute")
				.addModifiers(PUBLIC) //
				.addAnnotation(ClassName.get("javax.persistence", "Entity")) //
				.superclass(ParameterizedTypeName.get(ClassName.get("com.sandpolis.core.instance.data", "Attribute"),
						type));

		// Add value field
		attributeClass.addField(newValueField(attributeType, type).build());

		// Add get method
		attributeClass.addMethod(newGetMethod(type).build());

		// Add set method
		attributeClass.addMethod(newSetMethod(type).build());

		// Add timestamp method
		attributeClass.addMethod(newTimestampMethod().build());

		// Add serialize method
		attributeClass.addMethod(newSerializeMethod(type).build());

		// Add merge method
		attributeClass.addMethod(newMergeMethod(type).build());

		// Output the class
		JavaFile.builder(getProject().getName() + ".data", attributeClass.build())
				.addFileComment("This source file was automatically generated by the Sandpolis codegen plugin.")
				.skipJavaLangImports(true).build().writeTo(getProject().file("gen/main/java"));
	}

	public void generateListAttributeImpl(String attributeType) throws IOException {
		var type = Utils.toType(attributeType);

		// Alter the type to be a list
		var listType = ParameterizedTypeName.get(ClassName.get("java.util", "List"), type);

		var attributeListClass = TypeSpec
				.classBuilder(ClassName.bestGuess(attributeType).simpleName() + "ListAttribute") //
				.addModifiers(PUBLIC).addAnnotation(ClassName.get("javax.persistence", "Entity")) //
				.superclass(ParameterizedTypeName.get(ClassName.get("com.sandpolis.core.instance.data", "Attribute"),
						listType));

		// Add value field
		attributeListClass.addField(newValueField(attributeType, listType).build());

		// Add get method
		attributeListClass.addMethod(newListGetMethod(listType).build());

		// Add set method
		attributeListClass.addMethod(newListSetMethod(listType).build());

		// Add timestamp method
		attributeListClass.addMethod(newTimestampMethod().build());

		// Add serialize method
		attributeListClass.addMethod(newListSerializeMethod().build());

		// Add merge method
		attributeListClass.addMethod(newListMergeMethod().build());

		// Output the class
		JavaFile.builder(getProject().getName() + ".data", attributeListClass.build())
				.addFileComment("This source file was automatically generated by the Sandpolis codegen plugin.")
				.skipJavaLangImports(true).build().writeTo(getProject().file("gen/main/java"));
	}

	private FieldSpec.Builder newValueField(String attributeType, TypeName type) {
		var converterType = ClassName.get("com.sandpolis.core.instance.data",
				ClassName.bestGuess(attributeType).simpleName() + "Converter");
		var valueField = FieldSpec.builder(type, "value", PRIVATE);

		// Add converter annotation if applicable
		if (convertableTypes.contains(attributeType)) {
			valueField.addAnnotation(AnnotationSpec.builder(ClassName.get("javax.persistence", "Convert"))
					.addMember("converter", "$T.class", converterType).build());
		}

		// Add JPA annotation for array attributes
		if (arrayTypes.contains(attributeType)) {
			valueField.addAnnotation(ClassName.get("javax.persistence", "Lob"));
		}

		// Add JPA annotation for list attributes
		if (type instanceof ParameterizedTypeName) {
			valueField.addAnnotation(ClassName.get("javax.persistence", "ElementCollection"));
		}

		return valueField;
	}

	private MethodSpec.Builder newTimestampMethod() {
		return MethodSpec.methodBuilder("timestamp") //
				.addModifiers(PUBLIC) //
				.addAnnotation(Override.class) //
				.returns(java.util.Date.class) //
				.addStatement("return null");
	}

	private MethodSpec.Builder newGetMethod(TypeName type) {
		return MethodSpec.methodBuilder("get") //
				.addModifiers(PUBLIC) //
				.addAnnotation(Override.class) //
				.returns(type) //
				.addStatement("if (supplier != null) return supplier.get()") //
				.addStatement("return value");
	}

	private MethodSpec.Builder newSetMethod(TypeName type) {
		return MethodSpec.methodBuilder("set") //
				.addModifiers(PUBLIC) //
				.addAnnotation(Override.class) //
				.addParameter(type, "value") //
				.addStatement("this.value = value");
	}

	private MethodSpec.Builder newListGetMethod(TypeName listType) {
		return MethodSpec.methodBuilder("get") //
				.addModifiers(PUBLIC) //
				.addAnnotation(Override.class) //
				.returns(listType) //
				.addStatement("return value");
	}

	private MethodSpec.Builder newListSetMethod(TypeName listType) {
		return MethodSpec.methodBuilder("set") //
				.addModifiers(PUBLIC) //
				.addAnnotation(Override.class) //
				.addParameter(listType, "value") //
				.addStatement("this.value = value");
	}

	private MethodSpec.Builder newSerializeMethod(TypeName type) {
		return MethodSpec.methodBuilder("serialize") //
				.addModifiers(PUBLIC) //
				.addAnnotation(Override.class) //
				.returns(ClassName.get("com.sandpolis.core.instance", "Attribute", "ProtoAttribute")) //
				.addStatement("if (value == null) return null") //
				.addStatement("return $T.newBuilder().set$L(value).build()",
						ClassName.get("com.sandpolis.core.instance", "Attribute", "ProtoAttribute"),
						type.toString().replaceAll(".*\\.", ""));
	}

	private MethodSpec.Builder newListSerializeMethod() {
		return MethodSpec.methodBuilder("serialize") //
				.addModifiers(PUBLIC) //
				.addAnnotation(Override.class) //
				.returns(ClassName.get("com.sandpolis.core.instance", "Attribute", "ProtoAttribute")) //
				.addStatement("return $T.newBuilder().build()",
						ClassName.get("com.sandpolis.core.instance", "Attribute", "ProtoAttribute"));
	}

	private MethodSpec.Builder newMergeMethod(TypeName type) {
		return MethodSpec.methodBuilder("merge") //
				.addModifiers(PUBLIC) //
				.addAnnotation(Override.class) //
				.addException(Exception.class) //
				.addParameter(ClassName.get("com.sandpolis.core.instance", "Attribute", "ProtoAttribute"), "delta") //
				.addStatement("set(delta.get$L())", type.toString().replaceAll(".*\\.", ""));
	}

	private MethodSpec.Builder newListMergeMethod() {
		return MethodSpec.methodBuilder("merge") //
				.addModifiers(PUBLIC) //
				.addAnnotation(Override.class) //
				.addException(Exception.class) //
				.addParameter(ClassName.get("com.sandpolis.core.instance", "Attribute", "ProtoAttribute"), "delta") //
				.addStatement("set(null)");
	}

	public void generateConverter(String attributeType) throws IOException {
		var type = Utils.toType(attributeType);

		var converterClass = TypeSpec.classBuilder(ClassName.bestGuess(attributeType).simpleName() + "Converter")
				.addModifiers(PUBLIC).addAnnotation(ClassName.get("javax.persistence", "Converter"));

		// Add convertToDatabaseColumn
		var convertToDatabaseColumn = MethodSpec.methodBuilder("convertToDatabaseColumn") //
				.addModifiers(PUBLIC) //
				.addAnnotation(Override.class) //
				.addParameter(type, "value");

		// Add convertToEntityAttribute
		var convertToEntityAttribute = MethodSpec.methodBuilder("convertToEntityAttribute") //
				.addModifiers(PUBLIC) //
				.addAnnotation(Override.class) //
				.returns(type);

		switch (type.toString()) {
		case "com.sandpolis.core.foundation.Platform.OsType":
		case "com.sandpolis.core.instance.Metatypes.InstanceType":
		case "com.sandpolis.core.instance.Metatypes.InstanceFlavor":
			converterClass.addSuperinterface(ParameterizedTypeName
					.get(ClassName.get("javax.persistence", "AttributeConverter"), type, ClassName.get(Integer.class)));
			convertToDatabaseColumn.addStatement("return value.getNumber()").returns(Integer.class);
			convertToEntityAttribute.addStatement("return $T.forNumber(value)", type).addParameter(Integer.class,
					"value");
			break;
		case "java.security.cert.X509Certificate":
			converterClass.addSuperinterface(ParameterizedTypeName
					.get(ClassName.get("javax.persistence", "AttributeConverter"), type, ArrayTypeName.of(byte.class)));
			convertToDatabaseColumn
					.addCode(
							"try { return value.getEncoded(); } catch (Exception e) { throw new RuntimeException(e); }")
					.returns(byte[].class);
			convertToEntityAttribute.addParameter(byte[].class, "value").addCode(
					"try { return $T.parseCert(value); } catch (Exception e) { throw new RuntimeException(e); }",
					ClassName.get("com.sandpolis.core.foundation.util", "CertUtil"));
			break;
		}

		converterClass.addMethod(convertToDatabaseColumn.build());
		converterClass.addMethod(convertToEntityAttribute.build());

		// Output the class
		JavaFile.builder(getProject().getName() + ".data", converterClass.build())
				.addFileComment("This source file was automatically generated by the Sandpolis codegen plugin.")
				.skipJavaLangImports(true).build().writeTo(getProject().file("gen/main/java"));
	}
}
