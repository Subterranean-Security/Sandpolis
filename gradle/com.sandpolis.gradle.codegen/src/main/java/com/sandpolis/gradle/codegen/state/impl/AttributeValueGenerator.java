//============================================================================//
//                                                                            //
//                Copyright Â© 2015 - 2020 Subterranean Security               //
//                                                                            //
//  This source file is subject to the terms of the Mozilla Public License    //
//  version 2. You may not use this file except in compliance with the MPL    //
//  as published by the Mozilla Foundation at:                                //
//                                                                            //
//    https://mozilla.org/MPL/2.0                                             //
//                                                                            //
//=========================================================S A N D P O L I S==//
package com.sandpolis.gradle.codegen.state.impl;

import static com.sandpolis.gradle.codegen.state.STGenerator.ST_PACKAGE;
import static javax.lang.model.element.Modifier.PRIVATE;
import static javax.lang.model.element.Modifier.PUBLIC;

import java.io.IOException;
import java.util.List;

import org.gradle.api.DefaultTask;
import org.gradle.api.tasks.TaskAction;

import com.squareup.javapoet.AnnotationSpec;
import com.squareup.javapoet.ArrayTypeName;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.FieldSpec;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterizedTypeName;
import com.squareup.javapoet.TypeName;
import com.squareup.javapoet.TypeSpec;

/**
 * {@link AttributeValueGenerator} generates attribute value implementations for
 * the server module.
 */
public class AttributeValueGenerator extends DefaultTask {

	/**
	 * Types that are integral Hibernate entities.
	 */
	private static final List<ClassName> entityTypes = List.of( //
			ClassName.get(String.class), //
			ClassName.get(Boolean.class), //
			ClassName.get(Integer.class), //
			ClassName.get(Long.class), //
			ClassName.get(Double.class) //
	);

	/**
	 * Types that are arrays.
	 */
	private static final List<ArrayTypeName> arrayTypes = List.of( //
			ArrayTypeName.of(byte.class) //
	);

	/**
	 * Types that require a converter class.
	 */
	private static final List<ClassName> convertableTypes = List.of( //
			ClassName.get("com.sandpolis.core.foundation", "Platform", "OsType"), //
			ClassName.get("com.sandpolis.core.instance", "Metatypes", "InstanceType"), //
			ClassName.get("com.sandpolis.core.instance", "Metatypes", "InstanceFlavor"), //
			ClassName.get("java.security.cert", "X509Certificate") //
	);

	@TaskAction
	public void action() {

		entityTypes.stream().forEach(type -> {
			try {
				generateAttributeValue(type);
				generateListAttributeValue(type);
			} catch (IOException e) {
				throw new RuntimeException(e);
			}
		});

		arrayTypes.stream().forEach(type -> {
			try {
				generateArrayAttributeValue(type);
			} catch (IOException e) {
				throw new RuntimeException(e);
			}
		});

		convertableTypes.stream().forEach(type -> {
			try {
				generateAttributeValue(type);
				generateListAttributeValue(type);
			} catch (IOException e) {
				throw new RuntimeException(e);
			}
		});
	}

	/**
	 * Generate an attribute value implementation for an array type.
	 *
	 * @param type The array type
	 * @throws IOException
	 */
	private void generateArrayAttributeValue(ArrayTypeName type) throws IOException {
		var av = TypeSpec //
				.classBuilder(type.componentType.box().toString().replaceAll(".*\\.", "") + "ArrayAttributeValue") //
				.addModifiers(PUBLIC) //
				.addAnnotation(ClassName.get("javax.persistence", "Embeddable")) //
				.addSuperinterface(ParameterizedTypeName.get(ClassName.get(ST_PACKAGE, "STAttributeValue"), type));

		{
			// Add value field
			var field = FieldSpec.builder(type, "value", PRIVATE) //
					.addAnnotation(ClassName.get("javax.persistence", "Lob"));
			av.addField(field.build());
		}

		{
			// Add timestamp field
			av.addField(FieldSpec.builder(long.class, "timestamp", PRIVATE).build());
		}

		{
			// Add get method
			var method = MethodSpec.methodBuilder("get") //
					.addModifiers(PUBLIC) //
					.addAnnotation(Override.class) //
					.returns(type) //
					.addStatement("return value");
			av.addMethod(method.build());
		}

		{
			// Add timestamp method
			var method = MethodSpec.methodBuilder("timestamp") //
					.addModifiers(PUBLIC) //
					.addAnnotation(Override.class) //
					.returns(long.class) //
					.addStatement("return timestamp");
			av.addMethod(method.build());
		}

		// Output the class
		JavaFile.builder(getProject().getName() + ".state", av.build())
				.addFileComment("This source file was automatically generated by the Sandpolis codegen plugin.")
				.skipJavaLangImports(true).build().writeTo(getProject().file("gen/main/java"));
	}

	/**
	 * Generate an attribute value implementation for a scalar type.
	 *
	 * @param type
	 * @throws IOException
	 */
	private void generateAttributeValue(ClassName type) throws IOException {

		var av = TypeSpec //
				.classBuilder(type.simpleName() + "AttributeValue") //
				.addModifiers(PUBLIC) //
				.addAnnotation(ClassName.get("javax.persistence", "Embeddable")) //
				.addSuperinterface(ParameterizedTypeName.get(ClassName.get(ST_PACKAGE, "STAttributeValue"), type));

		{
			// Add value field
			av.addField(newValueField(type).build());
		}

		{
			// Add timestamp field
			av.addField(FieldSpec.builder(long.class, "timestamp", PRIVATE).build());
		}

		{
			// Add get method
			var method = MethodSpec.methodBuilder("get") //
					.addModifiers(PUBLIC) //
					.addAnnotation(Override.class) //
					.returns(type) //
					.addStatement("return value");
			av.addMethod(method.build());

		}

		{
			// Add timestamp method
			var method = MethodSpec.methodBuilder("timestamp") //
					.addModifiers(PUBLIC) //
					.addAnnotation(Override.class) //
					.returns(long.class) //
					.addStatement("return timestamp");
			av.addMethod(method.build());
		}

		// Output the class
		JavaFile.builder(getProject().getName() + ".state", av.build())
				.addFileComment("This source file was automatically generated by the Sandpolis codegen plugin.")
				.skipJavaLangImports(true).build().writeTo(getProject().file("gen/main/java"));
	}

	private void generateListAttributeValue(ClassName type) throws IOException {

		// Alter the type to be a list
		var listType = ParameterizedTypeName.get(ClassName.get("java.util", "List"), type);

		var av = TypeSpec //
				.classBuilder(type.simpleName() + "ListAttributeValue") //
				.addModifiers(PUBLIC).addAnnotation(ClassName.get("javax.persistence", "Embeddable")) //
				.addSuperinterface(ParameterizedTypeName.get(ClassName.get(ST_PACKAGE, "STAttributeValue"), listType));

		{
			// Add value field
			av.addField(newValueField(listType).build());
		}

		{
			// Add timestamp field
			av.addField(FieldSpec.builder(long.class, "timestamp", PRIVATE).build());
		}

		{
			// Add get method
			var method = MethodSpec.methodBuilder("get") //
					.addModifiers(PUBLIC) //
					.addAnnotation(Override.class) //
					.returns(listType) //
					.addStatement("return value");
			av.addMethod(method.build());
		}

		{
			// Add timestamp method
			var method = MethodSpec.methodBuilder("timestamp") //
					.addModifiers(PUBLIC) //
					.addAnnotation(Override.class) //
					.returns(long.class) //
					.addStatement("return timestamp");
			av.addMethod(method.build());
		}

		// Output the class
		JavaFile.builder(getProject().getName() + ".state", av.build())
				.addFileComment("This source file was automatically generated by the Sandpolis codegen plugin.")
				.skipJavaLangImports(true).build().writeTo(getProject().file("gen/main/java"));
	}

	private FieldSpec.Builder newValueField(TypeName type) {

		var valueField = FieldSpec.builder(type, "value", PRIVATE);

		// Add converter annotation if applicable
		if (convertableTypes.contains(type)) {
			valueField.addAnnotation( //
					AnnotationSpec.builder(ClassName.get("javax.persistence", "Convert"))
							.addMember("converter", "$T.class", ClassName.get(ST_PACKAGE + ".converter",
									type.toString().replaceAll(".*\\.", "").replace("[]", "Array") + "Converter"))
							.build());
		}

		// Add JPA annotation for list attributes
		if (type instanceof ParameterizedTypeName) {
			valueField.addAnnotation(ClassName.get("javax.persistence", "ElementCollection"));
		}

		return valueField;
	}
}
