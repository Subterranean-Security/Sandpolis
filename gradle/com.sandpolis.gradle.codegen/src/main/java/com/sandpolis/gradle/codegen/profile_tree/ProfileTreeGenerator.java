//============================================================================//
//                                                                            //
//                Copyright Â© 2015 - 2020 Subterranean Security               //
//                                                                            //
//  This source file is subject to the terms of the Mozilla Public License    //
//  version 2. You may not use this file except in compliance with the MPL    //
//  as published by the Mozilla Foundation at:                                //
//                                                                            //
//    https://mozilla.org/MPL/2.0                                             //
//                                                                            //
//=========================================================S A N D P O L I S==//
package com.sandpolis.gradle.codegen.profile_tree;

import static javax.lang.model.element.Modifier.FINAL;
import static javax.lang.model.element.Modifier.PUBLIC;

import javax.lang.model.SourceVersion;

import org.gradle.api.DefaultTask;
import org.gradle.api.tasks.TaskAction;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.sandpolis.gradle.codegen.ConfigExtension;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.TypeSpec;

/**
 * Generator for document bindings.
 *
 * @author cilki
 */
public abstract class ProfileTreeGenerator extends DefaultTask {

	protected static final ClassName DOCUMENT_TYPE = ClassName.bestGuess("com.sandpolis.core.instance.data.Document");

	@TaskAction
	public void action() throws Exception {

		// Load the schema
		var tree = new ObjectMapper().readValue(
				((ConfigExtension) getProject().getExtensions().getByName("codegen")).profileTreeSpec,
				CollectionSpec.class);

		// Check tree preconditions
		validateCollection(tree);

		// Create the root class
		TypeSpec.Builder root = TypeSpec.classBuilder("DocumentBindings").addModifiers(PUBLIC, FINAL);

		// Generate the bindings
		processCollection(root, tree);

		JavaFile.builder(getProject().getName(), root.build())
				.addFileComment("This source file was automatically generated by the Sandpolis codegen plugin.")
				.skipJavaLangImports(true).build().writeTo(getProject().file("gen/main/java"));
	}

	/**
	 * Assert the validity the given collection.
	 */
	public void validateCollection(CollectionSpec collection) {

		// Name must be a valid Java identifier
		if (!SourceVersion.isIdentifier(collection.name))
			throw new RuntimeException("Invalid collection name: " + collection.name);

		// Tag must be positive
		if (collection.tag <= 0)
			throw new RuntimeException("Found invalid tag on collection: " + collection.name);

		// Validate subattributes
		if (collection.attributes != null) {
			for (var subattribute : collection.attributes) {
				validateAttribute(subattribute);
			}
		}

		// Validate subdocuments
		if (collection.documents != null) {
			for (var subdocument : collection.documents) {
				validateDocument(subdocument);
			}
		}
	}

	/**
	 * Assert the validity the given document.
	 */
	public void validateDocument(DocumentSpec document) {

		// Name must be a valid Java identifier
		if (!SourceVersion.isIdentifier(document.name))
			throw new RuntimeException("Invalid document name: " + document.name);

		// Tag must be positive
		if (document.tag <= 0)
			throw new RuntimeException("Found invalid tag on document: " + document.name);

		// Validate subattributes
		if (document.attributes != null) {
			for (var subattribute : document.attributes) {
				validateAttribute(subattribute);
			}
		}

		// Validate subdocuments
		if (document.documents != null) {
			for (var subdocument : document.documents) {
				validateDocument(subdocument);
			}
		}
	}

	/**
	 * Assert the validity the given attribute.
	 */
	public void validateAttribute(AttributeSpec attribute) {

		// Name must be a valid Java identifier
		if (!SourceVersion.isIdentifier(attribute.name))
			throw new RuntimeException("Invalid attribute name: " + attribute.name);

		// Tag must be positive
		if (attribute.tag <= 0)
			throw new RuntimeException("Found invalid tag on attribute: " + attribute.name);

		// Type must be present
		if (attribute.type == null)
			throw new RuntimeException("Missing type on attribute: " + attribute.name);
	}

	/**
	 * Emit the given attribute into the given parent type.
	 */
	public abstract void processAttribute(TypeSpec.Builder parent, AttributeSpec attribute);

	/**
	 * Emit the given collection.
	 */
	public abstract void processCollection(TypeSpec.Builder parent, CollectionSpec collection);

	/**
	 * Emit the given document.
	 */
	public abstract void processDocument(TypeSpec.Builder parent, DocumentSpec document);
}
