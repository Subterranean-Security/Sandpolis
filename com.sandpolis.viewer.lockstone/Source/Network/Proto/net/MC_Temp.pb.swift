// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: com/sandpolis/core/proto/net/MC_Temp.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

struct Net_RQ_Screenshot {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Net_RS_Screenshot {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var data: Data = SwiftProtobuf.Internal.emptyData

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Net_FsHandleOptions {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Indicates whether size should be included in listings
  var size: Bool = false

  /// Indicates whether creation timestamps should be included in listings
  var ctime: Bool = false

  /// Indicates whether modification timestamps should be included in listings
  var mtime: Bool = false

  /// Indicates whether access timestamps should be included in listings
  var atime: Bool = false

  /// Indicates whether MIME types should be included in listings
  var mime: Bool = false

  /// The file owner
  var owner: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
/// A FileListlet is a component of a directory listing.
struct Net_FileListlet {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Indicates whether the file is a directory
  var directory: Bool = false

  /// The file's name
  var name: String = String()

  /// The file's creation time
  var ctime: Int64 = 0

  /// The file's modification time
  var mtime: Int64 = 0

  /// The file's access time
  var atime: Int64 = 0

  /// The file's size in bytes or number of elements if directory
  var size: Int64 = 0

  /// The file's MIME type
  var mime: String = String()

  var updateType: Net_FileListlet.UpdateType = .entryCreate

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum UpdateType: SwiftProtobuf.Enum {
    typealias RawValue = Int

    /// Indicates an entry has been added
    case entryCreate // = 0

    /// Indicates an entry has been removed
    case entryDelete // = 1

    /// Indicates an entry has been modified
    case entryModify // = 2

    /// Indicates some updates were dropped and the listing should be refreshed
    case overflow // = 3
    case UNRECOGNIZED(Int)

    init() {
      self = .entryCreate
    }

    init?(rawValue: Int) {
      switch rawValue {
      case 0: self = .entryCreate
      case 1: self = .entryDelete
      case 2: self = .entryModify
      case 3: self = .overflow
      default: self = .UNRECOGNIZED(rawValue)
      }
    }

    var rawValue: Int {
      switch self {
      case .entryCreate: return 0
      case .entryDelete: return 1
      case .entryModify: return 2
      case .overflow: return 3
      case .UNRECOGNIZED(let i): return i
      }
    }

  }

  init() {}
}

#if swift(>=4.2)

extension Net_FileListlet.UpdateType: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Net_FileListlet.UpdateType] = [
    .entryCreate,
    .entryDelete,
    .entryModify,
    .overflow,
  ]
}

#endif  // swift(>=4.2)

///*
/// Updates to a directory listing.
struct Net_EV_FileListing {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var fmid: Int32 = 0

  /// The directory's absolute path
  var path: String = String()

  /// Listing updates
  var listing: [Net_FileListlet] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
/// Request a directory listing.
struct Net_RQ_FileListing {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var path: String {
    get {return _storage._path}
    set {_uniqueStorage()._path = newValue}
  }

  var options: Net_FsHandleOptions {
    get {return _storage._options ?? Net_FsHandleOptions()}
    set {_uniqueStorage()._options = newValue}
  }
  /// Returns true if `options` has been explicitly set.
  var hasOptions: Bool {return _storage._options != nil}
  /// Clears the value of `options`. Subsequent reads from it will return its default value.
  mutating func clearOptions() {_uniqueStorage()._options = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// Response to a directory listing request.
struct Net_RS_FileListing {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The directory's absolute path
  var path: String = String()

  /// The directory listing
  var listing: [Net_FileListlet] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Net_RQ_FileDelete {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var path: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Net_RQ_Execute {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var type: String = String()

  var command: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

struct Net_RS_Execute {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var exitCode: Int32 = 0

  var result: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "net"

extension Net_RQ_Screenshot: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RQ_Screenshot"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Net_RQ_Screenshot, rhs: Net_RQ_Screenshot) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Net_RS_Screenshot: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RS_Screenshot"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "data"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBytesField(value: &self.data)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.data.isEmpty {
      try visitor.visitSingularBytesField(value: self.data, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Net_RS_Screenshot, rhs: Net_RS_Screenshot) -> Bool {
    if lhs.data != rhs.data {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Net_FsHandleOptions: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FsHandleOptions"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "size"),
    2: .same(proto: "ctime"),
    3: .same(proto: "mtime"),
    4: .same(proto: "atime"),
    5: .same(proto: "mime"),
    6: .same(proto: "owner"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.size)
      case 2: try decoder.decodeSingularBoolField(value: &self.ctime)
      case 3: try decoder.decodeSingularBoolField(value: &self.mtime)
      case 4: try decoder.decodeSingularBoolField(value: &self.atime)
      case 5: try decoder.decodeSingularBoolField(value: &self.mime)
      case 6: try decoder.decodeSingularBoolField(value: &self.owner)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.size != false {
      try visitor.visitSingularBoolField(value: self.size, fieldNumber: 1)
    }
    if self.ctime != false {
      try visitor.visitSingularBoolField(value: self.ctime, fieldNumber: 2)
    }
    if self.mtime != false {
      try visitor.visitSingularBoolField(value: self.mtime, fieldNumber: 3)
    }
    if self.atime != false {
      try visitor.visitSingularBoolField(value: self.atime, fieldNumber: 4)
    }
    if self.mime != false {
      try visitor.visitSingularBoolField(value: self.mime, fieldNumber: 5)
    }
    if self.owner != false {
      try visitor.visitSingularBoolField(value: self.owner, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Net_FsHandleOptions, rhs: Net_FsHandleOptions) -> Bool {
    if lhs.size != rhs.size {return false}
    if lhs.ctime != rhs.ctime {return false}
    if lhs.mtime != rhs.mtime {return false}
    if lhs.atime != rhs.atime {return false}
    if lhs.mime != rhs.mime {return false}
    if lhs.owner != rhs.owner {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Net_FileListlet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FileListlet"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "directory"),
    2: .same(proto: "name"),
    3: .same(proto: "ctime"),
    4: .same(proto: "mtime"),
    5: .same(proto: "atime"),
    6: .same(proto: "size"),
    7: .same(proto: "mime"),
    8: .standard(proto: "update_type"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.directory)
      case 2: try decoder.decodeSingularStringField(value: &self.name)
      case 3: try decoder.decodeSingularInt64Field(value: &self.ctime)
      case 4: try decoder.decodeSingularInt64Field(value: &self.mtime)
      case 5: try decoder.decodeSingularInt64Field(value: &self.atime)
      case 6: try decoder.decodeSingularInt64Field(value: &self.size)
      case 7: try decoder.decodeSingularStringField(value: &self.mime)
      case 8: try decoder.decodeSingularEnumField(value: &self.updateType)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.directory != false {
      try visitor.visitSingularBoolField(value: self.directory, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if self.ctime != 0 {
      try visitor.visitSingularInt64Field(value: self.ctime, fieldNumber: 3)
    }
    if self.mtime != 0 {
      try visitor.visitSingularInt64Field(value: self.mtime, fieldNumber: 4)
    }
    if self.atime != 0 {
      try visitor.visitSingularInt64Field(value: self.atime, fieldNumber: 5)
    }
    if self.size != 0 {
      try visitor.visitSingularInt64Field(value: self.size, fieldNumber: 6)
    }
    if !self.mime.isEmpty {
      try visitor.visitSingularStringField(value: self.mime, fieldNumber: 7)
    }
    if self.updateType != .entryCreate {
      try visitor.visitSingularEnumField(value: self.updateType, fieldNumber: 8)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Net_FileListlet, rhs: Net_FileListlet) -> Bool {
    if lhs.directory != rhs.directory {return false}
    if lhs.name != rhs.name {return false}
    if lhs.ctime != rhs.ctime {return false}
    if lhs.mtime != rhs.mtime {return false}
    if lhs.atime != rhs.atime {return false}
    if lhs.size != rhs.size {return false}
    if lhs.mime != rhs.mime {return false}
    if lhs.updateType != rhs.updateType {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Net_FileListlet.UpdateType: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "ENTRY_CREATE"),
    1: .same(proto: "ENTRY_DELETE"),
    2: .same(proto: "ENTRY_MODIFY"),
    3: .same(proto: "OVERFLOW"),
  ]
}

extension Net_EV_FileListing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".EV_FileListing"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fmid"),
    2: .same(proto: "path"),
    3: .same(proto: "listing"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.fmid)
      case 2: try decoder.decodeSingularStringField(value: &self.path)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.listing)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.fmid != 0 {
      try visitor.visitSingularInt32Field(value: self.fmid, fieldNumber: 1)
    }
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 2)
    }
    if !self.listing.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.listing, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Net_EV_FileListing, rhs: Net_EV_FileListing) -> Bool {
    if lhs.fmid != rhs.fmid {return false}
    if lhs.path != rhs.path {return false}
    if lhs.listing != rhs.listing {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Net_RQ_FileListing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RQ_FileListing"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
    2: .same(proto: "options"),
  ]

  fileprivate class _StorageClass {
    var _path: String = String()
    var _options: Net_FsHandleOptions? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _path = source._path
      _options = source._options
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._path)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._options)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._path.isEmpty {
        try visitor.visitSingularStringField(value: _storage._path, fieldNumber: 1)
      }
      if let v = _storage._options {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Net_RQ_FileListing, rhs: Net_RQ_FileListing) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._path != rhs_storage._path {return false}
        if _storage._options != rhs_storage._options {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Net_RS_FileListing: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RS_FileListing"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
    2: .same(proto: "listing"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.path)
      case 2: try decoder.decodeRepeatedMessageField(value: &self.listing)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 1)
    }
    if !self.listing.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.listing, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Net_RS_FileListing, rhs: Net_RS_FileListing) -> Bool {
    if lhs.path != rhs.path {return false}
    if lhs.listing != rhs.listing {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Net_RQ_FileDelete: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RQ_FileDelete"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.path)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Net_RQ_FileDelete, rhs: Net_RQ_FileDelete) -> Bool {
    if lhs.path != rhs.path {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Net_RQ_Execute: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RQ_Execute"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "type"),
    2: .same(proto: "command"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.type)
      case 2: try decoder.decodeSingularStringField(value: &self.command)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 1)
    }
    if !self.command.isEmpty {
      try visitor.visitSingularStringField(value: self.command, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Net_RQ_Execute, rhs: Net_RQ_Execute) -> Bool {
    if lhs.type != rhs.type {return false}
    if lhs.command != rhs.command {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Net_RS_Execute: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RS_Execute"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "exitCode"),
    2: .same(proto: "result"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularInt32Field(value: &self.exitCode)
      case 2: try decoder.decodeSingularStringField(value: &self.result)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.exitCode != 0 {
      try visitor.visitSingularInt32Field(value: self.exitCode, fieldNumber: 1)
    }
    if !self.result.isEmpty {
      try visitor.visitSingularStringField(value: self.result, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Net_RS_Execute, rhs: Net_RS_Execute) -> Bool {
    if lhs.exitCode != rhs.exitCode {return false}
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
