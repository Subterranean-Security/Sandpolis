// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: com/sandpolis/core/proto/net/MC_Plugin.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///*
/// Plugin metadata.
struct Net_PluginDescriptor {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var id: String = String()

  var coordinate: String = String()

  var name: String = String()

  var version: String = String()

  var description_p: String = String()

  var trustAuthority: String = String()

  var icon: Data = SwiftProtobuf.Internal.emptyData

  var enabled: Bool = false

  var componentSizeMega: Int32 = 0

  var componentSizeMicro: Int32 = 0

  var componentSizeJfx: Int32 = 0

  var componentSizeCli: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
/// A request for the instance's plugin list.
struct Net_RQ_PluginList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
/// A response to a plugin list request.
struct Net_RS_PluginList {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var plugin: [Net_PluginDescriptor] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
/// A request to download an artifact.
struct Net_RQ_ArtifactDownload {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The coordinates of the artifact to download
  var coordinates: String = String()

  /// Whether it's acceptable to receive the external location of the artifact only
  var location: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
/// The download response bearing the artifact binary or the artifact's address.
struct Net_RS_ArtifactDownload {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var source: Net_RS_ArtifactDownload.OneOf_Source? = nil

  /// The artifact binary
  var binary: Data {
    get {
      if case .binary(let v)? = source {return v}
      return SwiftProtobuf.Internal.emptyData
    }
    set {source = .binary(newValue)}
  }

  /// The artifact's HTTP location
  var url: String {
    get {
      if case .url(let v)? = source {return v}
      return String()
    }
    set {source = .url(newValue)}
  }

  /// The artifact's maven central coordinates
  var coordinates: String {
    get {
      if case .coordinates(let v)? = source {return v}
      return String()
    }
    set {source = .coordinates(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Source: Equatable {
    /// The artifact binary
    case binary(Data)
    /// The artifact's HTTP location
    case url(String)
    /// The artifact's maven central coordinates
    case coordinates(String)

  #if !swift(>=4.1)
    static func ==(lhs: Net_RS_ArtifactDownload.OneOf_Source, rhs: Net_RS_ArtifactDownload.OneOf_Source) -> Bool {
      switch (lhs, rhs) {
      case (.binary(let l), .binary(let r)): return l == r
      case (.url(let l), .url(let r)): return l == r
      case (.coordinates(let l), .coordinates(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}
}

///*
/// A request to install a server plugin.
struct Net_RQ_PluginInstall {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var source: Net_RQ_PluginInstall.OneOf_Source? = nil

  /// The plugin binary
  var pluginBinary: Data {
    get {
      if case .pluginBinary(let v)? = source {return v}
      return SwiftProtobuf.Internal.emptyData
    }
    set {source = .pluginBinary(newValue)}
  }

  /// The plugin's HTTP location
  var pluginURL: String {
    get {
      if case .pluginURL(let v)? = source {return v}
      return String()
    }
    set {source = .pluginURL(newValue)}
  }

  /// The plugin's maven central coordinates
  var pluginCoordinates: String {
    get {
      if case .pluginCoordinates(let v)? = source {return v}
      return String()
    }
    set {source = .pluginCoordinates(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_Source: Equatable {
    /// The plugin binary
    case pluginBinary(Data)
    /// The plugin's HTTP location
    case pluginURL(String)
    /// The plugin's maven central coordinates
    case pluginCoordinates(String)

  #if !swift(>=4.1)
    static func ==(lhs: Net_RQ_PluginInstall.OneOf_Source, rhs: Net_RQ_PluginInstall.OneOf_Source) -> Bool {
      switch (lhs, rhs) {
      case (.pluginBinary(let l), .pluginBinary(let r)): return l == r
      case (.pluginURL(let l), .pluginURL(let r)): return l == r
      case (.pluginCoordinates(let l), .pluginCoordinates(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "net"

extension Net_PluginDescriptor: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".PluginDescriptor"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    12: .same(proto: "coordinate"),
    2: .same(proto: "name"),
    3: .same(proto: "version"),
    4: .same(proto: "description"),
    5: .standard(proto: "trust_authority"),
    6: .same(proto: "icon"),
    7: .same(proto: "enabled"),
    8: .standard(proto: "component_size_mega"),
    9: .standard(proto: "component_size_micro"),
    10: .standard(proto: "component_size_jfx"),
    11: .standard(proto: "component_size_cli"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.id)
      case 2: try decoder.decodeSingularStringField(value: &self.name)
      case 3: try decoder.decodeSingularStringField(value: &self.version)
      case 4: try decoder.decodeSingularStringField(value: &self.description_p)
      case 5: try decoder.decodeSingularStringField(value: &self.trustAuthority)
      case 6: try decoder.decodeSingularBytesField(value: &self.icon)
      case 7: try decoder.decodeSingularBoolField(value: &self.enabled)
      case 8: try decoder.decodeSingularInt32Field(value: &self.componentSizeMega)
      case 9: try decoder.decodeSingularInt32Field(value: &self.componentSizeMicro)
      case 10: try decoder.decodeSingularInt32Field(value: &self.componentSizeJfx)
      case 11: try decoder.decodeSingularInt32Field(value: &self.componentSizeCli)
      case 12: try decoder.decodeSingularStringField(value: &self.coordinate)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.id.isEmpty {
      try visitor.visitSingularStringField(value: self.id, fieldNumber: 1)
    }
    if !self.name.isEmpty {
      try visitor.visitSingularStringField(value: self.name, fieldNumber: 2)
    }
    if !self.version.isEmpty {
      try visitor.visitSingularStringField(value: self.version, fieldNumber: 3)
    }
    if !self.description_p.isEmpty {
      try visitor.visitSingularStringField(value: self.description_p, fieldNumber: 4)
    }
    if !self.trustAuthority.isEmpty {
      try visitor.visitSingularStringField(value: self.trustAuthority, fieldNumber: 5)
    }
    if !self.icon.isEmpty {
      try visitor.visitSingularBytesField(value: self.icon, fieldNumber: 6)
    }
    if self.enabled != false {
      try visitor.visitSingularBoolField(value: self.enabled, fieldNumber: 7)
    }
    if self.componentSizeMega != 0 {
      try visitor.visitSingularInt32Field(value: self.componentSizeMega, fieldNumber: 8)
    }
    if self.componentSizeMicro != 0 {
      try visitor.visitSingularInt32Field(value: self.componentSizeMicro, fieldNumber: 9)
    }
    if self.componentSizeJfx != 0 {
      try visitor.visitSingularInt32Field(value: self.componentSizeJfx, fieldNumber: 10)
    }
    if self.componentSizeCli != 0 {
      try visitor.visitSingularInt32Field(value: self.componentSizeCli, fieldNumber: 11)
    }
    if !self.coordinate.isEmpty {
      try visitor.visitSingularStringField(value: self.coordinate, fieldNumber: 12)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Net_PluginDescriptor, rhs: Net_PluginDescriptor) -> Bool {
    if lhs.id != rhs.id {return false}
    if lhs.coordinate != rhs.coordinate {return false}
    if lhs.name != rhs.name {return false}
    if lhs.version != rhs.version {return false}
    if lhs.description_p != rhs.description_p {return false}
    if lhs.trustAuthority != rhs.trustAuthority {return false}
    if lhs.icon != rhs.icon {return false}
    if lhs.enabled != rhs.enabled {return false}
    if lhs.componentSizeMega != rhs.componentSizeMega {return false}
    if lhs.componentSizeMicro != rhs.componentSizeMicro {return false}
    if lhs.componentSizeJfx != rhs.componentSizeJfx {return false}
    if lhs.componentSizeCli != rhs.componentSizeCli {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Net_RQ_PluginList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RQ_PluginList"
  static let _protobuf_nameMap = SwiftProtobuf._NameMap()

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let _ = try decoder.nextFieldNumber() {
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Net_RQ_PluginList, rhs: Net_RQ_PluginList) -> Bool {
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Net_RS_PluginList: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RS_PluginList"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "plugin"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.plugin)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.plugin.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.plugin, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Net_RS_PluginList, rhs: Net_RS_PluginList) -> Bool {
    if lhs.plugin != rhs.plugin {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Net_RQ_ArtifactDownload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RQ_ArtifactDownload"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "coordinates"),
    2: .same(proto: "location"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.coordinates)
      case 2: try decoder.decodeSingularBoolField(value: &self.location)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.coordinates.isEmpty {
      try visitor.visitSingularStringField(value: self.coordinates, fieldNumber: 1)
    }
    if self.location != false {
      try visitor.visitSingularBoolField(value: self.location, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Net_RQ_ArtifactDownload, rhs: Net_RQ_ArtifactDownload) -> Bool {
    if lhs.coordinates != rhs.coordinates {return false}
    if lhs.location != rhs.location {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Net_RS_ArtifactDownload: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RS_ArtifactDownload"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "binary"),
    2: .same(proto: "url"),
    3: .same(proto: "coordinates"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1:
        if self.source != nil {try decoder.handleConflictingOneOf()}
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {self.source = .binary(v)}
      case 2:
        if self.source != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.source = .url(v)}
      case 3:
        if self.source != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.source = .coordinates(v)}
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    switch self.source {
    case .binary(let v)?:
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    case .url(let v)?:
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    case .coordinates(let v)?:
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Net_RS_ArtifactDownload, rhs: Net_RS_ArtifactDownload) -> Bool {
    if lhs.source != rhs.source {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Net_RQ_PluginInstall: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RQ_PluginInstall"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "plugin_binary"),
    2: .standard(proto: "plugin_url"),
    3: .standard(proto: "plugin_coordinates"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1:
        if self.source != nil {try decoder.handleConflictingOneOf()}
        var v: Data?
        try decoder.decodeSingularBytesField(value: &v)
        if let v = v {self.source = .pluginBinary(v)}
      case 2:
        if self.source != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.source = .pluginURL(v)}
      case 3:
        if self.source != nil {try decoder.handleConflictingOneOf()}
        var v: String?
        try decoder.decodeSingularStringField(value: &v)
        if let v = v {self.source = .pluginCoordinates(v)}
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    switch self.source {
    case .pluginBinary(let v)?:
      try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
    case .pluginURL(let v)?:
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    case .pluginCoordinates(let v)?:
      try visitor.visitSingularStringField(value: v, fieldNumber: 3)
    case nil: break
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Net_RQ_PluginInstall, rhs: Net_RQ_PluginInstall) -> Bool {
    if lhs.source != rhs.source {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
