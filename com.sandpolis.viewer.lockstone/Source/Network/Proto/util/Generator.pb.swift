// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: com/sandpolis/core/proto/util/Generator.proto
//
// For information on using the generated types, please see the documenation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

///*
/// The payload type.
enum Util_OutputPayload: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// TODO remove prefix
  /// Output a configuration for another payload type
  case outputConfig // = 0

  /// Output a full-featured heavyweight client written in Java
  case outputMega // = 1

  /// Output a lightweight native client written in C++
  case outputMicro // = 2
  case UNRECOGNIZED(Int)

  init() {
    self = .outputConfig
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .outputConfig
    case 1: self = .outputMega
    case 2: self = .outputMicro
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .outputConfig: return 0
    case .outputMega: return 1
    case .outputMicro: return 2
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Util_OutputPayload: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Util_OutputPayload] = [
    .outputConfig,
    .outputMega,
    .outputMicro,
  ]
}

#endif  // swift(>=4.2)

///*
/// The format of the output.
enum Util_OutputFormat: SwiftProtobuf.Enum {
  typealias RawValue = Int

  /// File formats
  case jar // = 0
  case exe // = 1
  case elf // = 2
  case bat // = 3
  case sh // = 4
  case rb // = 5
  case py // = 6

  /// Other formats
  case qr // = 7
  case url // = 8
  case UNRECOGNIZED(Int)

  init() {
    self = .jar
  }

  init?(rawValue: Int) {
    switch rawValue {
    case 0: self = .jar
    case 1: self = .exe
    case 2: self = .elf
    case 3: self = .bat
    case 4: self = .sh
    case 5: self = .rb
    case 6: self = .py
    case 7: self = .qr
    case 8: self = .url
    default: self = .UNRECOGNIZED(rawValue)
    }
  }

  var rawValue: Int {
    switch self {
    case .jar: return 0
    case .exe: return 1
    case .elf: return 2
    case .bat: return 3
    case .sh: return 4
    case .rb: return 5
    case .py: return 6
    case .qr: return 7
    case .url: return 8
    case .UNRECOGNIZED(let i): return i
    }
  }

}

#if swift(>=4.2)

extension Util_OutputFormat: CaseIterable {
  // The compiler won't synthesize support with the UNRECOGNIZED case.
  static var allCases: [Util_OutputFormat] = [
    .jar,
    .exe,
    .elf,
    .bat,
    .sh,
    .rb,
    .py,
    .qr,
    .url,
  ]
}

#endif  // swift(>=4.2)

///*
/// Identifies the target host of a potential connection.
struct Util_NetworkTarget {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The network address
  var address: String = String()

  /// The numeric port
  var port: Int32 = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
/// Identifies supported client features, platforms, and architectures. 
struct Util_FeatureSet {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Supported operating systems
  var supportedOs: [Util_OsType] = []

  /// Supported system architectures
  var supportedArch: [Util_Architecture] = []

  /// Supported plugins
  var plugin: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
/// Information on the result of a generation.
struct Util_GenReport {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The overall success of the generation attempt
  var result: Bool = false

  /// A comment on the result of the generation attempt
  var comment: String = String()

  /// The start timestamp of the generation
  var timestamp: Int64 = 0

  /// How long the generation took in milliseconds
  var duration: Int64 = 0

  /// A MD5 hash of the result
  var outputMd5: String = String()

  /// A SHA256 hash of the result
  var outputSha256: String = String()

  /// A SHA512 hash of the result
  var outputSha512: String = String()

  /// The size of the result in bytes
  var outputSize: Int64 = 0

  /// The type of installer generated
  var payload: Util_OutputPayload = .outputConfig

  /// The type of installer generated
  var format: Util_OutputFormat = .jar

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
/// A LoopConfig contains all parameters and information needed to establish a
/// new connection with a ConnectionLoop.
struct Util_LoopConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The list of network targets to attempt
  var target: [Util_NetworkTarget] = []

  /// Indicates whether strict certificate checking will be enabled
  var strictCerts: Bool = false

  /// The maximum number of conenction iterations to attempt in the worst case
  var maxIterations: Int32 = 0

  /// The initial connection timeout
  var timeout: Int32 = 0

  /// The maximum connection timeout
  var maxTimeout: Int32 = 0

  /// The timeout smoothing factor which determines how quickly the maximum
  /// timeout is reached
  var timeoutFlatness: Double = 0

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
/// Configuration specific to the network module.
struct Util_NetworkConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The ConnectionLoop configuration
  var loopConfig: Util_LoopConfig {
    get {return _storage._loopConfig ?? Util_LoopConfig()}
    set {_uniqueStorage()._loopConfig = newValue}
  }
  /// Returns true if `loopConfig` has been explicitly set.
  var hasLoopConfig: Bool {return _storage._loopConfig != nil}
  /// Clears the value of `loopConfig`. Subsequent reads from it will return its default value.
  mutating func clearLoopConfig() {_uniqueStorage()._loopConfig = nil}

  /// When true, the client will not be able to connect to services outside of 
  /// the Sandpolis network.
  var strictNetwork: Bool {
    get {return _storage._strictNetwork}
    set {_uniqueStorage()._strictNetwork = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// Configuration specific to payload execution.
struct Util_ExecutionConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Whether the initial installer should be deleted upon successful execution
  var melt: Bool = false

  /// Whether the client should be automatically started on boot
  var auto: Bool = false

  /// Whether the client should force install if the initial installation fails
  /// for any reason.
  var recover: Bool = false

  /// Installation paths. Keys are the enum numbers from OsType.
  var installPath: Dictionary<Int32,String> = [:]

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}
}

///*
/// Configuration specific to the authentication module.
struct Util_AuthenticationConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The name of the auth group
  /// (Only needed if group type is KEY)
  var groupName: String {
    get {return _storage._groupName}
    set {_uniqueStorage()._groupName = newValue}
  }

  var authOneof: OneOf_AuthOneof? {
    get {return _storage._authOneof}
    set {_uniqueStorage()._authOneof = newValue}
  }

  /// Key authentication mechanism
  var key: Util_KeyContainer {
    get {
      if case .key(let v)? = _storage._authOneof {return v}
      return Util_KeyContainer()
    }
    set {_uniqueStorage()._authOneof = .key(newValue)}
  }

  /// Password authentication mechanism
  var password: Util_PasswordContainer {
    get {
      if case .password(let v)? = _storage._authOneof {return v}
      return Util_PasswordContainer()
    }
    set {_uniqueStorage()._authOneof = .password(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_AuthOneof: Equatable {
    /// Key authentication mechanism
    case key(Util_KeyContainer)
    /// Password authentication mechanism
    case password(Util_PasswordContainer)

  #if !swift(>=4.1)
    static func ==(lhs: Util_AuthenticationConfig.OneOf_AuthOneof, rhs: Util_AuthenticationConfig.OneOf_AuthOneof) -> Bool {
      switch (lhs, rhs) {
      case (.key(let l), .key(let r)): return l == r
      case (.password(let l), .password(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// Configuration specific to MEGA payloads.
struct Util_MegaConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var features: Util_FeatureSet {
    get {return _storage._features ?? Util_FeatureSet()}
    set {_uniqueStorage()._features = newValue}
  }
  /// Returns true if `features` has been explicitly set.
  var hasFeatures: Bool {return _storage._features != nil}
  /// Clears the value of `features`. Subsequent reads from it will return its default value.
  mutating func clearFeatures() {_uniqueStorage()._features = nil}

  var network: Util_NetworkConfig {
    get {return _storage._network ?? Util_NetworkConfig()}
    set {_uniqueStorage()._network = newValue}
  }
  /// Returns true if `network` has been explicitly set.
  var hasNetwork: Bool {return _storage._network != nil}
  /// Clears the value of `network`. Subsequent reads from it will return its default value.
  mutating func clearNetwork() {_uniqueStorage()._network = nil}

  var execution: Util_ExecutionConfig {
    get {return _storage._execution ?? Util_ExecutionConfig()}
    set {_uniqueStorage()._execution = newValue}
  }
  /// Returns true if `execution` has been explicitly set.
  var hasExecution: Bool {return _storage._execution != nil}
  /// Clears the value of `execution`. Subsequent reads from it will return its default value.
  mutating func clearExecution() {_uniqueStorage()._execution = nil}

  var authentication: Util_AuthenticationConfig {
    get {return _storage._authentication ?? Util_AuthenticationConfig()}
    set {_uniqueStorage()._authentication = newValue}
  }
  /// Returns true if `authentication` has been explicitly set.
  var hasAuthentication: Bool {return _storage._authentication != nil}
  /// Clears the value of `authentication`. Subsequent reads from it will return its default value.
  mutating func clearAuthentication() {_uniqueStorage()._authentication = nil}

  var downloader: Bool {
    get {return _storage._downloader}
    set {_uniqueStorage()._downloader = newValue}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// Configuration specific to MICRO payloads.
struct Util_MicroConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var network: Util_NetworkConfig {
    get {return _storage._network ?? Util_NetworkConfig()}
    set {_uniqueStorage()._network = newValue}
  }
  /// Returns true if `network` has been explicitly set.
  var hasNetwork: Bool {return _storage._network != nil}
  /// Clears the value of `network`. Subsequent reads from it will return its default value.
  mutating func clearNetwork() {_uniqueStorage()._network = nil}

  var execution: Util_ExecutionConfig {
    get {return _storage._execution ?? Util_ExecutionConfig()}
    set {_uniqueStorage()._execution = newValue}
  }
  /// Returns true if `execution` has been explicitly set.
  var hasExecution: Bool {return _storage._execution != nil}
  /// Clears the value of `execution`. Subsequent reads from it will return its default value.
  mutating func clearExecution() {_uniqueStorage()._execution = nil}

  var authentication: Util_AuthenticationConfig {
    get {return _storage._authentication ?? Util_AuthenticationConfig()}
    set {_uniqueStorage()._authentication = newValue}
  }
  /// Returns true if `authentication` has been explicitly set.
  var hasAuthentication: Bool {return _storage._authentication != nil}
  /// Clears the value of `authentication`. Subsequent reads from it will return its default value.
  mutating func clearAuthentication() {_uniqueStorage()._authentication = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

///*
/// A GenConfig contains all parameters and information needed to launch a new 
/// generator.
struct Util_GenConfig {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// The request ID
  var id: Int64 {
    get {return _storage._id}
    set {_uniqueStorage()._id = newValue}
  }

  /// The user that requested the generation
  var requestUser: String {
    get {return _storage._requestUser}
    set {_uniqueStorage()._requestUser = newValue}
  }

  /// The payload type
  var payload: Util_OutputPayload {
    get {return _storage._payload}
    set {_uniqueStorage()._payload = newValue}
  }

  /// The output format of this client
  var format: Util_OutputFormat {
    get {return _storage._format}
    set {_uniqueStorage()._format = newValue}
  }

  /// An optional identifier
  var clientIdentifier: String {
    get {return _storage._clientIdentifier}
    set {_uniqueStorage()._clientIdentifier = newValue}
  }

  var payloadConfig: OneOf_PayloadConfig? {
    get {return _storage._payloadConfig}
    set {_uniqueStorage()._payloadConfig = newValue}
  }

  var mega: Util_MegaConfig {
    get {
      if case .mega(let v)? = _storage._payloadConfig {return v}
      return Util_MegaConfig()
    }
    set {_uniqueStorage()._payloadConfig = .mega(newValue)}
  }

  var micro: Util_MicroConfig {
    get {
      if case .micro(let v)? = _storage._payloadConfig {return v}
      return Util_MicroConfig()
    }
    set {_uniqueStorage()._payloadConfig = .micro(newValue)}
  }

  var unknownFields = SwiftProtobuf.UnknownStorage()

  enum OneOf_PayloadConfig: Equatable {
    case mega(Util_MegaConfig)
    case micro(Util_MicroConfig)

  #if !swift(>=4.1)
    static func ==(lhs: Util_GenConfig.OneOf_PayloadConfig, rhs: Util_GenConfig.OneOf_PayloadConfig) -> Bool {
      switch (lhs, rhs) {
      case (.mega(let l), .mega(let r)): return l == r
      case (.micro(let l), .micro(let r)): return l == r
      default: return false
      }
    }
  #endif
  }

  init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "util"

extension Util_OutputPayload: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "OUTPUT_CONFIG"),
    1: .same(proto: "OUTPUT_MEGA"),
    2: .same(proto: "OUTPUT_MICRO"),
  ]
}

extension Util_OutputFormat: SwiftProtobuf._ProtoNameProviding {
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    0: .same(proto: "JAR"),
    1: .same(proto: "EXE"),
    2: .same(proto: "ELF"),
    3: .same(proto: "BAT"),
    4: .same(proto: "SH"),
    5: .same(proto: "RB"),
    6: .same(proto: "PY"),
    7: .same(proto: "QR"),
    8: .same(proto: "URL"),
  ]
}

extension Util_NetworkTarget: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NetworkTarget"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "port"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.address)
      case 2: try decoder.decodeSingularInt32Field(value: &self.port)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if self.port != 0 {
      try visitor.visitSingularInt32Field(value: self.port, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Util_NetworkTarget, rhs: Util_NetworkTarget) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.port != rhs.port {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Util_FeatureSet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".FeatureSet"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "supported_os"),
    2: .standard(proto: "supported_arch"),
    3: .same(proto: "plugin"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedEnumField(value: &self.supportedOs)
      case 2: try decoder.decodeRepeatedEnumField(value: &self.supportedArch)
      case 3: try decoder.decodeRepeatedStringField(value: &self.plugin)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.supportedOs.isEmpty {
      try visitor.visitPackedEnumField(value: self.supportedOs, fieldNumber: 1)
    }
    if !self.supportedArch.isEmpty {
      try visitor.visitPackedEnumField(value: self.supportedArch, fieldNumber: 2)
    }
    if !self.plugin.isEmpty {
      try visitor.visitRepeatedStringField(value: self.plugin, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Util_FeatureSet, rhs: Util_FeatureSet) -> Bool {
    if lhs.supportedOs != rhs.supportedOs {return false}
    if lhs.supportedArch != rhs.supportedArch {return false}
    if lhs.plugin != rhs.plugin {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Util_GenReport: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GenReport"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
    2: .same(proto: "comment"),
    3: .same(proto: "timestamp"),
    4: .same(proto: "duration"),
    5: .standard(proto: "output_md5"),
    6: .standard(proto: "output_sha256"),
    7: .standard(proto: "output_sha512"),
    9: .standard(proto: "output_size"),
    10: .same(proto: "payload"),
    11: .same(proto: "format"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.result)
      case 2: try decoder.decodeSingularStringField(value: &self.comment)
      case 3: try decoder.decodeSingularInt64Field(value: &self.timestamp)
      case 4: try decoder.decodeSingularInt64Field(value: &self.duration)
      case 5: try decoder.decodeSingularStringField(value: &self.outputMd5)
      case 6: try decoder.decodeSingularStringField(value: &self.outputSha256)
      case 7: try decoder.decodeSingularStringField(value: &self.outputSha512)
      case 9: try decoder.decodeSingularInt64Field(value: &self.outputSize)
      case 10: try decoder.decodeSingularEnumField(value: &self.payload)
      case 11: try decoder.decodeSingularEnumField(value: &self.format)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.result != false {
      try visitor.visitSingularBoolField(value: self.result, fieldNumber: 1)
    }
    if !self.comment.isEmpty {
      try visitor.visitSingularStringField(value: self.comment, fieldNumber: 2)
    }
    if self.timestamp != 0 {
      try visitor.visitSingularInt64Field(value: self.timestamp, fieldNumber: 3)
    }
    if self.duration != 0 {
      try visitor.visitSingularInt64Field(value: self.duration, fieldNumber: 4)
    }
    if !self.outputMd5.isEmpty {
      try visitor.visitSingularStringField(value: self.outputMd5, fieldNumber: 5)
    }
    if !self.outputSha256.isEmpty {
      try visitor.visitSingularStringField(value: self.outputSha256, fieldNumber: 6)
    }
    if !self.outputSha512.isEmpty {
      try visitor.visitSingularStringField(value: self.outputSha512, fieldNumber: 7)
    }
    if self.outputSize != 0 {
      try visitor.visitSingularInt64Field(value: self.outputSize, fieldNumber: 9)
    }
    if self.payload != .outputConfig {
      try visitor.visitSingularEnumField(value: self.payload, fieldNumber: 10)
    }
    if self.format != .jar {
      try visitor.visitSingularEnumField(value: self.format, fieldNumber: 11)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Util_GenReport, rhs: Util_GenReport) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.comment != rhs.comment {return false}
    if lhs.timestamp != rhs.timestamp {return false}
    if lhs.duration != rhs.duration {return false}
    if lhs.outputMd5 != rhs.outputMd5 {return false}
    if lhs.outputSha256 != rhs.outputSha256 {return false}
    if lhs.outputSha512 != rhs.outputSha512 {return false}
    if lhs.outputSize != rhs.outputSize {return false}
    if lhs.payload != rhs.payload {return false}
    if lhs.format != rhs.format {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Util_LoopConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".LoopConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "target"),
    2: .standard(proto: "strict_certs"),
    3: .standard(proto: "max_iterations"),
    4: .same(proto: "timeout"),
    5: .standard(proto: "max_timeout"),
    6: .standard(proto: "timeout_flatness"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeRepeatedMessageField(value: &self.target)
      case 2: try decoder.decodeSingularBoolField(value: &self.strictCerts)
      case 3: try decoder.decodeSingularInt32Field(value: &self.maxIterations)
      case 4: try decoder.decodeSingularInt32Field(value: &self.timeout)
      case 5: try decoder.decodeSingularInt32Field(value: &self.maxTimeout)
      case 6: try decoder.decodeSingularDoubleField(value: &self.timeoutFlatness)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.target.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.target, fieldNumber: 1)
    }
    if self.strictCerts != false {
      try visitor.visitSingularBoolField(value: self.strictCerts, fieldNumber: 2)
    }
    if self.maxIterations != 0 {
      try visitor.visitSingularInt32Field(value: self.maxIterations, fieldNumber: 3)
    }
    if self.timeout != 0 {
      try visitor.visitSingularInt32Field(value: self.timeout, fieldNumber: 4)
    }
    if self.maxTimeout != 0 {
      try visitor.visitSingularInt32Field(value: self.maxTimeout, fieldNumber: 5)
    }
    if self.timeoutFlatness != 0 {
      try visitor.visitSingularDoubleField(value: self.timeoutFlatness, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Util_LoopConfig, rhs: Util_LoopConfig) -> Bool {
    if lhs.target != rhs.target {return false}
    if lhs.strictCerts != rhs.strictCerts {return false}
    if lhs.maxIterations != rhs.maxIterations {return false}
    if lhs.timeout != rhs.timeout {return false}
    if lhs.maxTimeout != rhs.maxTimeout {return false}
    if lhs.timeoutFlatness != rhs.timeoutFlatness {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Util_NetworkConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".NetworkConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "loop_config"),
    2: .standard(proto: "strict_network"),
  ]

  fileprivate class _StorageClass {
    var _loopConfig: Util_LoopConfig? = nil
    var _strictNetwork: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _loopConfig = source._loopConfig
      _strictNetwork = source._strictNetwork
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._loopConfig)
        case 2: try decoder.decodeSingularBoolField(value: &_storage._strictNetwork)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._loopConfig {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if _storage._strictNetwork != false {
        try visitor.visitSingularBoolField(value: _storage._strictNetwork, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Util_NetworkConfig, rhs: Util_NetworkConfig) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._loopConfig != rhs_storage._loopConfig {return false}
        if _storage._strictNetwork != rhs_storage._strictNetwork {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Util_ExecutionConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ExecutionConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "melt"),
    2: .same(proto: "auto"),
    3: .same(proto: "recover"),
    4: .standard(proto: "install_path"),
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.melt)
      case 2: try decoder.decodeSingularBoolField(value: &self.auto)
      case 3: try decoder.decodeSingularBoolField(value: &self.recover)
      case 4: try decoder.decodeMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt32,SwiftProtobuf.ProtobufString>.self, value: &self.installPath)
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.melt != false {
      try visitor.visitSingularBoolField(value: self.melt, fieldNumber: 1)
    }
    if self.auto != false {
      try visitor.visitSingularBoolField(value: self.auto, fieldNumber: 2)
    }
    if self.recover != false {
      try visitor.visitSingularBoolField(value: self.recover, fieldNumber: 3)
    }
    if !self.installPath.isEmpty {
      try visitor.visitMapField(fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufInt32,SwiftProtobuf.ProtobufString>.self, value: self.installPath, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Util_ExecutionConfig, rhs: Util_ExecutionConfig) -> Bool {
    if lhs.melt != rhs.melt {return false}
    if lhs.auto != rhs.auto {return false}
    if lhs.recover != rhs.recover {return false}
    if lhs.installPath != rhs.installPath {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Util_AuthenticationConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".AuthenticationConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "group_name"),
    2: .same(proto: "key"),
    3: .same(proto: "password"),
  ]

  fileprivate class _StorageClass {
    var _groupName: String = String()
    var _authOneof: Util_AuthenticationConfig.OneOf_AuthOneof?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _groupName = source._groupName
      _authOneof = source._authOneof
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._groupName)
        case 2:
          var v: Util_KeyContainer?
          if let current = _storage._authOneof {
            try decoder.handleConflictingOneOf()
            if case .key(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._authOneof = .key(v)}
        case 3:
          var v: Util_PasswordContainer?
          if let current = _storage._authOneof {
            try decoder.handleConflictingOneOf()
            if case .password(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._authOneof = .password(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._groupName.isEmpty {
        try visitor.visitSingularStringField(value: _storage._groupName, fieldNumber: 1)
      }
      switch _storage._authOneof {
      case .key(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      case .password(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Util_AuthenticationConfig, rhs: Util_AuthenticationConfig) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._groupName != rhs_storage._groupName {return false}
        if _storage._authOneof != rhs_storage._authOneof {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Util_MegaConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MegaConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "features"),
    2: .same(proto: "network"),
    3: .same(proto: "execution"),
    4: .same(proto: "authentication"),
    5: .same(proto: "downloader"),
  ]

  fileprivate class _StorageClass {
    var _features: Util_FeatureSet? = nil
    var _network: Util_NetworkConfig? = nil
    var _execution: Util_ExecutionConfig? = nil
    var _authentication: Util_AuthenticationConfig? = nil
    var _downloader: Bool = false

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _features = source._features
      _network = source._network
      _execution = source._execution
      _authentication = source._authentication
      _downloader = source._downloader
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._features)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._network)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._execution)
        case 4: try decoder.decodeSingularMessageField(value: &_storage._authentication)
        case 5: try decoder.decodeSingularBoolField(value: &_storage._downloader)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._features {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._network {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._execution {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
      if let v = _storage._authentication {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 4)
      }
      if _storage._downloader != false {
        try visitor.visitSingularBoolField(value: _storage._downloader, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Util_MegaConfig, rhs: Util_MegaConfig) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._features != rhs_storage._features {return false}
        if _storage._network != rhs_storage._network {return false}
        if _storage._execution != rhs_storage._execution {return false}
        if _storage._authentication != rhs_storage._authentication {return false}
        if _storage._downloader != rhs_storage._downloader {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Util_MicroConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".MicroConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "network"),
    2: .same(proto: "execution"),
    3: .same(proto: "authentication"),
  ]

  fileprivate class _StorageClass {
    var _network: Util_NetworkConfig? = nil
    var _execution: Util_ExecutionConfig? = nil
    var _authentication: Util_AuthenticationConfig? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _network = source._network
      _execution = source._execution
      _authentication = source._authentication
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularMessageField(value: &_storage._network)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._execution)
        case 3: try decoder.decodeSingularMessageField(value: &_storage._authentication)
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if let v = _storage._network {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
      }
      if let v = _storage._execution {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
      if let v = _storage._authentication {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Util_MicroConfig, rhs: Util_MicroConfig) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._network != rhs_storage._network {return false}
        if _storage._execution != rhs_storage._execution {return false}
        if _storage._authentication != rhs_storage._authentication {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Util_GenConfig: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".GenConfig"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "id"),
    2: .standard(proto: "request_user"),
    3: .same(proto: "payload"),
    4: .same(proto: "format"),
    5: .standard(proto: "client_identifier"),
    6: .same(proto: "mega"),
    7: .same(proto: "micro"),
  ]

  fileprivate class _StorageClass {
    var _id: Int64 = 0
    var _requestUser: String = String()
    var _payload: Util_OutputPayload = .outputConfig
    var _format: Util_OutputFormat = .jar
    var _clientIdentifier: String = String()
    var _payloadConfig: Util_GenConfig.OneOf_PayloadConfig?

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _id = source._id
      _requestUser = source._requestUser
      _payload = source._payload
      _format = source._format
      _clientIdentifier = source._clientIdentifier
      _payloadConfig = source._payloadConfig
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularInt64Field(value: &_storage._id)
        case 2: try decoder.decodeSingularStringField(value: &_storage._requestUser)
        case 3: try decoder.decodeSingularEnumField(value: &_storage._payload)
        case 4: try decoder.decodeSingularEnumField(value: &_storage._format)
        case 5: try decoder.decodeSingularStringField(value: &_storage._clientIdentifier)
        case 6:
          var v: Util_MegaConfig?
          if let current = _storage._payloadConfig {
            try decoder.handleConflictingOneOf()
            if case .mega(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payloadConfig = .mega(v)}
        case 7:
          var v: Util_MicroConfig?
          if let current = _storage._payloadConfig {
            try decoder.handleConflictingOneOf()
            if case .micro(let m) = current {v = m}
          }
          try decoder.decodeSingularMessageField(value: &v)
          if let v = v {_storage._payloadConfig = .micro(v)}
        default: break
        }
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if _storage._id != 0 {
        try visitor.visitSingularInt64Field(value: _storage._id, fieldNumber: 1)
      }
      if !_storage._requestUser.isEmpty {
        try visitor.visitSingularStringField(value: _storage._requestUser, fieldNumber: 2)
      }
      if _storage._payload != .outputConfig {
        try visitor.visitSingularEnumField(value: _storage._payload, fieldNumber: 3)
      }
      if _storage._format != .jar {
        try visitor.visitSingularEnumField(value: _storage._format, fieldNumber: 4)
      }
      if !_storage._clientIdentifier.isEmpty {
        try visitor.visitSingularStringField(value: _storage._clientIdentifier, fieldNumber: 5)
      }
      switch _storage._payloadConfig {
      case .mega(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 6)
      case .micro(let v)?:
        try visitor.visitSingularMessageField(value: v, fieldNumber: 7)
      case nil: break
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: Util_GenConfig, rhs: Util_GenConfig) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._id != rhs_storage._id {return false}
        if _storage._requestUser != rhs_storage._requestUser {return false}
        if _storage._payload != rhs_storage._payload {return false}
        if _storage._format != rhs_storage._format {return false}
        if _storage._clientIdentifier != rhs_storage._clientIdentifier {return false}
        if _storage._payloadConfig != rhs_storage._payloadConfig {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
